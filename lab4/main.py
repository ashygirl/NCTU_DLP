from __future__ import unicode_literals, print_function, division
from io import open
import unicodedata
import string
import re
import random
import time
import math
import torch
import torch.nn as nn
from torch import optim
import torch.nn.functional as F
import matplotlib.pyplot as plt
plt.switch_backend('agg')
import matplotlib.ticker as ticker
import numpy as np
from os import system
from nltk.translate.bleu_score import SmoothingFunction, sentence_bleu
from model import EncoderRNN,SimpleDecoderRNN,AttentionDecoderRNN
from train import trainIters
from datahelper import DataTransformer

"""========================================================================================
The main.py includes the following template functions:

1. Encoder, decoder
2. Training function
3. BLEU-4 score function

You have to modify them to complete the lab.
In addition, there are still other functions that you have to 
implement by yourself.

1. Your own dataloader (design in your own way, not necessary Pytorch Dataloader)
2. Output your results (BLEU-4 score, correction words)
3. Plot loss/score
4. Load/save weights
========================================================================================"""

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
SOS_token = 0
EOS_token = 1
#----------Hyper Parameters----------#
hidden_size = 256  # LSTM hidden size
vocab_size = 29  # The number of vocabulary:vocab_size==input_size ,containing:SOS,EOS,UNK,a-z
teacher_forcing_ratio = 0.5
LR = 0.05
decoder_type='attention'

################################
#Example inputs of compute_bleu
################################
#The target word
reference = 'variable'
#The word generated by your model
output = 'varable'

#compute BLEU-4 score
def compute_bleu(output, reference):
    cc = SmoothingFunction()
    return sentence_bleu([reference], output,weights=(0.25, 0.25, 0.25, 0.25),smoothing_function=cc.method1)


if __name__=='__main__':
    """
    load training data
    """
    datatransformer = DataTransformer()
    training_list = datatransformer.build_training_set(path='train.json')
    training_tensor_list = []
    # convert list to tensor
    for training_pair in training_list:
        input_tensor = torch.tensor(training_pair[0], device=device).view(-1, 1)
        target_tensor = torch.tensor(training_pair[1], device=device).view(-1, 1)
        training_tensor_list.append((input_tensor, target_tensor))
    """
    model
    """
    encoder=EncoderRNN(vocab_size,hidden_size).to(device)
    decoder=AttentionDecoderRNN(vocab_size,hidden_size,datatransformer.MAX_LENGTH).to(device)
    """
    train
    """
    epochs=10
    for epoch in range(1,epochs+1):
        loss=trainIters(decoder_type,encoder,decoder,training_tensor_list,learning_rate=0.05,max_length=datatransformer.MAX_LENGTH,teacher_forcing_ratio=0.5)
        print(f'epoch{epoch:>2d} loss:{loss:.4f}')


